#X3D V3.0 utf8 Titania

META "icon" "about:icon"
META "title" "about:gears"

EXTERNPROTO Rotor [
  inputOutput SFTime     cycleInterval
  inputOutput SFBool     loop
  outputOnly  SFRotation value_changed
]
"../Library/Rotor.wrl"

PROTO Gear [
  inputOutput    SFFloat teeth 10
  inputOutput    SFFloat toothDepth 2
  inputOutput    SFFloat innerRadius 1
  inputOutput    SFFloat outerRadius 4
  inputOutput    SFFloat width 1
  initializeOnly SFFloat creaseAngle 0.6
]
{
  DEF Gear IndexedFaceSet {
    creaseAngle IS creaseAngle
    coord Coordinate { }
  }

  Script {
    inputOutput    SFFloat teeth IS teeth
    inputOutput    SFFloat toothDepth IS toothDepth
    inputOutput    SFFloat innerRadius IS innerRadius
    inputOutput    SFFloat outerRadius IS outerRadius
    inputOutput    SFFloat width IS width
    initializeOnly SFNode  gear USE Gear

    url "vrmlscript:

function initialize ()
{
	print ('### Generating gear ...');

	var indices = gear .set_coordIndex
	var points  = gear .coord .point;

	var cos = Math .cos;
	var sin = Math .sin;

	var r0 = innerRadius;
	var r1 = outerRadius - toothDepth / 2;
	var r2 = outerRadius + toothDepth / 2;
	var da = 2 * Math .PI / teeth / 4;


	// Generate front face indices
	
	for (var i = 0; i < teeth; ++ i)
	{
		var index = i * 3;
	
		indices [indices .length] = index;
		indices [indices .length] = index + 1;
		indices [indices .length] = index + 2;
		indices [indices .length] = index + 4;
		indices [indices .length] = index + 3;
		indices [indices .length] = -1;
	}

	// Generate front face points
	
	for (var i = 0; i < teeth + 1; ++ i)
	{
		var angle = i * 2 * Math .PI / teeth;

		points [points .length] = new SFVec3f (r0 * cos (angle), r0 * sin (angle), width * 0.5);
		points [points .length] = new SFVec3f (r1 * cos (angle), r1 * sin (angle), width * 0.5);
		points [points .length] = new SFVec3f (r1 * cos (angle + 3 * da), r1 * sin (angle + 3 * da), width * 0.5);
	}
	
	points .length = points .length - 1;
	
	points [points .length] = new SFVec3f ();
	points [points .length] = new SFVec3f ();
	points [points .length] = new SFVec3f ();


	// Generate front sides of teeth indices

	for (var i = 0; i < teeth; ++ i)
	{
		var index = i * 4;
	
		indices [indices .length] = points .length + index;
		indices [indices .length] = points .length + index + 1;
		indices [indices .length] = points .length + index + 2;
		indices [indices .length] = points .length + index + 3;
		indices [indices .length] = -1;
	}

	// Generate front sides of teeth points

	for (var i = 0; i < teeth; ++ i)
	{
		var angle = i * 2 * Math .PI / teeth;
		
		points [points .length] = new SFVec3f (r1 * cos (angle),          r1 * sin (angle),          width * 0.5);
		points [points .length] = new SFVec3f (r2 * cos (angle + da),     r2 * sin (angle + da),     width * 0.5);
		points [points .length] = new SFVec3f (r2 * cos (angle + 2 * da), r2 * sin (angle + 2 * da), width * 0.5);
		points [points .length] = new SFVec3f (r1 * cos (angle + 3 * da), r1 * sin (angle + 3 * da), width * 0.5);
	}


	// Generate back face indices
	
	for (var i = 0; i < teeth; ++ i)
	{
		var index = i * 3;
	
		indices [indices .length] = points .length + index;
		indices [indices .length] = points .length + index + 3;
		indices [indices .length] = points .length + index + 4;
		indices [indices .length] = points .length + index + 2;
		indices [indices .length] = points .length + index + 1;
		indices [indices .length] = -1;
	}

	// Generate back face points
	
	for (var i = 0; i < teeth + 1; ++ i)
	{
		var angle = i * 2 * Math .PI / teeth;

		points [points .length] = new SFVec3f (r0 * cos (angle), r0 * sin (angle), -width * 0.5);
		points [points .length] = new SFVec3f (r1 * cos (angle), r1 * sin (angle), -width * 0.5);
		points [points .length] = new SFVec3f (r1 * cos (angle + 3 * da), r1 * sin (angle + 3 * da), -width * 0.5);
	}

	points .length = points .length - 1;


	// Generate back sides of teeth indices

	for (var i = 0; i < teeth; ++ i)
	{
		var index = i * 4;
	
		indices [indices .length] = points .length + index;
		indices [indices .length] = points .length + index + 1;
		indices [indices .length] = points .length + index + 2;
		indices [indices .length] = points .length + index + 3;
		indices [indices .length] = -1;
	}

	// Generate front sides of teeth points

	for (var i = 0; i < teeth; ++ i)
	{
		var angle = i * 2 * Math .PI / teeth;
		
		points [points .length] = new SFVec3f (r1 * cos (angle + 3 * da), r1 * sin (angle + 3 * da), -width * 0.5);
		points [points .length] = new SFVec3f (r2 * cos (angle + 2 * da), r2 * sin (angle + 2 * da), -width * 0.5);
		points [points .length] = new SFVec3f (r2 * cos (angle + da),     r2 * sin (angle + da),     -width * 0.5);
		points [points .length] = new SFVec3f (r1 * cos (angle),          r1 * sin (angle),          -width * 0.5);	
	}


	// Generate outward faces of teeth indices

	for (var i = 0; i < teeth * 4; ++ i)
	{
		var index = i * 2;
	
		indices [indices .length] = points .length + index;
		indices [indices .length] = points .length + index + 1;
		indices [indices .length] = points .length + index + 3;
		indices [indices .length] = points .length + index + 2;
		indices [indices .length] = -1;
	}

	indices [indices .length - 3] = points .length + 1;
	indices [indices .length - 2] = points .length;
	
	// Generate outward faces of teeth points
	
	for (var i = 0; i < teeth; ++ i)
	{
	   var angle = i * 2 * Math .PI / teeth;
	   
		points [points .length] = new SFVec3f (r1 * cos (angle), r1 * sin (angle),  width * 0.5);
		points [points .length] = new SFVec3f (r1 * cos (angle), r1 * sin (angle), -width * 0.5);

		points [points .length] = new SFVec3f (r2 * cos (angle + da),   r2 * sin (angle + da),   width * 0.5);
		points [points .length] = new SFVec3f (r2 * cos (angle + da),   r2 * sin (angle + da),  -width * 0.5);

		points [points .length] = new SFVec3f (r2 * cos (angle + 2 * da), r2 * sin (angle + 2 * da),  width * 0.5);
		points [points .length] = new SFVec3f (r2 * cos (angle + 2 * da), r2 * sin (angle + 2 * da), -width * 0.5);

		points [points .length] = new SFVec3f (r1 * cos (angle + 3 * da), r1 * sin (angle + 3 * da),  width * 0.5);
		points [points .length] = new SFVec3f (r1 * cos (angle + 3 * da), r1 * sin (angle + 3 * da), -width * 0.5);
	}


	// Generate inside radius cylinder points
	
	for (var i = 0; i < teeth; ++ i)
	{
		var index = i * 2;
	
		indices [indices .length] = points .length + index;
		indices [indices .length] = points .length + index + 1;
		indices [indices .length] = points .length + index + 3;
		indices [indices .length] = points .length + index + 2;
		indices [indices .length] = -1;
	}
	
	indices [indices .length - 3] = points .length + 1;
	indices [indices .length - 2] = points .length;
		
	// Generate inside radius cylinder indices
	
	for (var i = 0; i < teeth + 1; ++ i)
	{
		var angle = i * 2 * Math .PI / teeth;
		points [points .length] = new SFVec3f (r0 * cos (angle), r0 * sin (angle), -width * 0.5);
		points [points .length] = new SFVec3f (r0 * cos (angle), r0 * sin (angle),  width * 0.5);
	}

	print ('### Generating gear done.');
}
"
  }
}

Viewpoint {
  description "Home"
  position 0 0 20
}

DEF RedRotor Rotor {
  cycleInterval 10
  loop TRUE
}

DEF GreenRotor Rotor {
  cycleInterval 5
  loop TRUE
}

DEF BlueRotor Rotor {
  cycleInterval 5
  loop TRUE
}

Transform {
  rotation 1 0 0 0.349066
  children Transform {
    rotation 0 1 0 0.523599
    children [
      Transform {
        translation -3 -2 0
        children DEF RedGear Transform {
          children Shape {
            appearance Appearance {
              material Material {
                diffuseColor 0.8 0.1 0
              }
            }
            geometry Gear {
              teeth 20
              toothDepth 0.7
            }
          }
        }
      }
      Transform {
        translation 3.1 -2 0
        rotation 0 1 0 3.14159
        children Transform {
          rotation 0 0 1 0.32
          children DEF GreenGear Transform {
            children Shape {
              appearance Appearance {
                material Material {
                  diffuseColor 0 0.8 0.2
                }
              }
              geometry Gear {
                toothDepth 0.7
                innerRadius 0.5
                outerRadius 2
                width 2
              }
            }
          }
        }
      }
      Transform {
        translation -3.1 4.2 0
        rotation 0 1 0 3.14159
        children Transform {
          rotation 0 0 -1 0.0200017
          children DEF BlueGear Transform {
            children Shape {
              appearance Appearance {
                material Material {
                  diffuseColor 0.2 0.2 1
                }
              }
              geometry Gear {
                toothDepth 0.7
                innerRadius 1.3
                outerRadius 2
                width 0.5
              }
            }
          }
        }
      }
    ]
  }
}

ROUTE RedRotor.value_changed TO RedGear.set_rotation
ROUTE GreenRotor.value_changed TO GreenGear.set_rotation
ROUTE BlueRotor.value_changed TO BlueGear.set_rotation
