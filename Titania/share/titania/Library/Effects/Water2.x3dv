#X3D V3.0 utf8 Titania V0.6.7

META "generator" "Titania V0.6.7, http://titania.create3000.de"
META "title" "Water Shader 2"

DEF Water2 Transform {
  children [
    DEF Timer TimeSensor {
      cycleInterval 31104000
      loop TRUE
    }
    DEF ElapsedTime ScalarInterpolator {
      key [
        0,
        1
      ]
      keyValue [
        0,
        3.1104e+07
      ]
    }
    DEF _1 ProximitySensor {
      size 1000 1000 1000
    }
    Shape {
      appearance Appearance {
        shaders DEF WaterShader2 ComposedShader {
          inputOnly   SFFloat set_time
          inputOutput SFVec3f position -0 0 10
          inputOutput SFInt32 waves 5
          inputOutput MFFloat amplitude [
            0.2,
            0.2,
            0.1,
            0.1,
            0.1
          ]
          inputOutput MFFloat waveLength [
            1.1,
            2.3,
            3.1,
            4.1,
            5.3
          ]
          inputOutput MFFloat speed [
            1.09,
            0.79,
            0.19,
            0.29,
            0.37
          ]
          inputOutput MFVec2f direction [
            0.1 0.2,
            0.3 0.4,
            0.5 0.6,
            0.7 0.8,
            0.9 0.1
          ]
          inputOutput SFFloat transparency 0.5
          inputOutput SFNode  texture ComposedCubeMapTexture {
            front ImageTexture {
              url [
                "../Textures/CubeMapTextures/LostValley/lostvalley_south.jpg",
                "/usr/share/titania/Library/Textures/CubeMapTextures/LostValley/lostvalley_south.jpg"
              ]
            }
            back ImageTexture {
              url [
                "../Textures/CubeMapTextures/LostValley/lostvalley_north.jpg",
                "/usr/share/titania/Library/Textures/CubeMapTextures/LostValley/lostvalley_north.jpg"
              ]
            }
            left ImageTexture {
              url [
                "../Textures/CubeMapTextures/LostValley/lostvalley_west.jpg",
                "/usr/share/titania/Library/Textures/CubeMapTextures/LostValley/lostvalley_west.jpg"
              ]
            }
            right ImageTexture {
              url [
                "../Textures/CubeMapTextures/LostValley/lostvalley_east.jpg",
                "/usr/share/titania/Library/Textures/CubeMapTextures/LostValley/lostvalley_east.jpg"
              ]
            }
            bottom ImageTexture {
              url [
                "../Textures/CubeMapTextures/LostValley/lostvalley_down.jpg",
                "/usr/share/titania/Library/Textures/CubeMapTextures/LostValley/lostvalley_down.jpg"
              ]
            }
            top ImageTexture {
              url [
                "../Textures/CubeMapTextures/LostValley/lostvalley_up.jpg",
                "/usr/share/titania/Library/Textures/CubeMapTextures/LostValley/lostvalley_up.jpg"
              ]
            }
          }

          language "GLSL"
          parts [
            ShaderPart {
              url "data:text/plain,
#version 120

#define WAVE_MAX 8

uniform float set_time;
uniform vec3  position;
uniform int   waves;
uniform float amplitude [WAVE_MAX];
uniform float waveLength [WAVE_MAX];
uniform float speed [WAVE_MAX];
uniform vec2  direction [WAVE_MAX];

varying vec3 translation;
varying vec3 worldNormal;
varying vec3 reflection;
varying vec3 eyeNormal;

const float M_PI = 3.14159;

float
wave (in int i, in float x, in float y)
{
	float frequency = 2 * M_PI / waveLength [i];
	float phase     = speed [i] * frequency;
	float theta     = dot (direction [i], vec2 (x, y));

	return amplitude [i] * sin (theta * frequency + set_time * phase);
}

float
waveHeight (in float x, in float y)
{
	float height = 0.0;

	for (int i = 0; i < waves; ++i)
		height += wave (i, x, y);

	return height;
}

float
dWaved (in int i, in float x, in float y, in float d)
{
	float frequency = 2 * M_PI / waveLength [i];
	float phase     = speed [i] * frequency;
	float theta     = dot (direction [i], vec2 (x, y));
	float A         = amplitude [i] * d * frequency;

	return A * cos (theta * frequency + set_time * phase);
}

vec3
waveNormal (in float x, in float y)
{
	float dx = 0.0;
	float dy = 0.0;

	for (int i = 0; i < waves; ++i)
	{
		dx += dWaved (i, x, y, direction [i] .x);
		dy += dWaved (i, x, y, direction [i] .y);
	}

	vec3 n = vec3 (-dx, -dy, 1.0);

	return normalize (n);
}

void
main ()
{
	vec4 pos    = gl_Vertex;
	pos.y       = waveHeight (pos .x, pos .z);
	translation = position - pos .xyz / pos .w;
	worldNormal = waveNormal (pos .x, pos .z);
	reflection  = reflect (translation, worldNormal);
	eyeNormal   = gl_NormalMatrix * worldNormal;
	gl_Position = gl_ModelViewProjectionMatrix * pos;
}
"
            }
            ShaderPart {
              type "FRAGMENT"
              url "data:text/plain,
#version 120

uniform float       transparency;
uniform samplerCube texture;

varying vec3 reflection;

void
main ()
{
	vec3 color   = vec3 (textureCube (texture, reflection));
	gl_FragColor = vec4 (color, 1 - transparency);
}
"
            }
          ]
        }
      }
      geometry ElevationGrid {
        xDimension 60
        zDimension 60
      }
    }
  ]
}

ROUTE Timer.fraction_changed TO ElapsedTime.set_fraction
ROUTE ElapsedTime.value_changed TO WaterShader2.set_time
ROUTE _1.position_changed TO WaterShader2.set_position
