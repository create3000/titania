#X3D V3.3 utf8 Titania V0.6.7

META "generator" "Titania V0.6.7, http://titania.create3000.de"

DEF Water1 Transform {
  children [
    DEF Timer TimeSensor {
      cycleInterval 31104000
      loop TRUE
    }
    DEF ElapsedTime ScalarInterpolator {
      key [
        0,
        1
      ]
      keyValue [
        0,
        3.1104e+07
      ]
    }
    Shape {
      appearance Appearance {
        shaders DEF WaterShader1 ComposedShader {
          inputOutput SFFloat time 3.14092
          inputOutput SFInt32 numWaves 5
          inputOutput MFFloat amplitude [
            0.1,
            0.2,
            0.1,
            0.1,
            0.1
          ]
          inputOutput MFFloat waveLength [
            1,
            2,
            3,
            5,
            7
          ]
          inputOutput MFFloat speed [
            1,
            2,
            1,
            3,
            1
          ]
          inputOutput MFVec2f direction [
            0.1 0.2,
            0.3 0.4,
            0.5 0.6,
            0.7 0.8,
            0.9 0.1
          ]
          inputOutput SFColor color 1 1 1
          inputOutput SFFloat transparency 0
          inputOutput SFColor bottomColor 0 0.5 1
          inputOutput SFFloat bottomTransparency 0.5

          language "GLSL"
          parts [
            ShaderPart {
              url "data:text/plain,
#version 120

uniform float time;
uniform int   numWaves;
uniform float amplitude [8];
uniform float waveLength [8];
uniform float speed [8];
uniform vec2  direction [8];

varying vec3 position;

const float PI = 3.14159;

float wave (int i, float x, float y)
{
	float frequency = 2 * PI / waveLength [i];
	float phase     = speed [i] * frequency;
	float theta     = dot (direction [i], vec2 (x, y));
	return amplitude [i] * sin (theta * frequency + time * phase);
}

float waveHeight (float x, float y)
{
	float height = 0.0;
	for (int i = 0; i < numWaves; ++ i)
		height += wave (i, x, y);
	return height;
}

void main()
{
	vec4 pos    = gl_Vertex;
	pos .y      = waveHeight (pos .x, pos .z);
	position    = pos .xyz / pos .w;
	gl_Position = gl_ModelViewProjectionMatrix * pos;
}
"
            }
            ShaderPart {
              type "FRAGMENT"
              url "data:text/plain,
#version 120

uniform int   numWaves;
uniform float amplitude [8];
uniform vec3  color;
uniform float transparency;
uniform vec3  bottomColor;
uniform float bottomTransparency;

varying vec3 position;

void main ()
{
	float height = 0;
	for (int i = 0; i < numWaves; ++ i)
		height += amplitude [i];

	float alpha = ((height + position .y) / (2 * height));
	
	vec4 topColor    = vec4 (color, alpha * (1 - transparency));
	vec4 bottomColor = vec4 (bottomColor, alpha * (1 - bottomTransparency));

	gl_FragColor = mix (bottomColor, topColor, alpha);
}
"
            }
          ]
        }
      }
      geometry ElevationGrid {
        xDimension 30
        zDimension 30
        solid FALSE
      }
    }
  ]
}

ROUTE Timer.fraction_changed TO ElapsedTime.set_fraction
ROUTE ElapsedTime.value_changed TO WaterShader1.set_time
