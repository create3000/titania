#!/usr/bin/perl
# -*- Mode: Perl; coding: utf-8; tab-width: 3; indent-tabs-mode: t; c-basic-offset: 3 -*-

package X3D::Parser;

use strict;
use warnings;
use v5.10.0;
use open qw/:std :utf8/;

use XML::LibXML;

#libxml-libxml-perl

use Glib;
#libglib-perl

use Switch;
#libswitch-perl

sub find_data_file {
	my $name = shift;
	my @dirs = Glib::get_system_data_dirs ();

	unshift @dirs, Glib::get_user_data_dir ();

	foreach my $dir (@dirs)
	{
		my $filename = "$dir/$name";

		return $filename if -f $filename;
	}

	die "Couldn't find '$name' in any of these directories:\n" . (join "\n", @dirs) . "\n";
}

my $DTDDirectory = "/titania/dtd";
my $Info         = "/titania/info";
my $X3DCatalog   = find_data_file ("$DTDDirectory/x3d-catalog.xml");
my $NodeIndex    = find_data_file ("$Info/node-index.txt");
my $FieldIndex   = find_data_file ("$Info/field-index.txt");

my $RecomemndedSystemId = find_data_file ("$DTDDirectory/x3d-3.3.dtd");
my $RecommendedPublicId = "ISO//Web3D//DTD X3D 3.3//EN";
my $RecomemndedVersion  = "3.3";

XML::LibXML -> load_catalog ($X3DCatalog);


sub new {
	my ($class, $options) = @_;

	my $document = new XML::LibXML ($options) -> load_xml ($options);

	my $self = {
		nodes                => new Glib::KeyFile (),
		dom                  => $document,
		specificationVersion => 3.3,
		profile              => undef,
		components           => [ ],
		units                => [ ],
		metaData             => [ ],
		externProtos         => [ ],
		externProtosIndex    => { },
		protos               => [ ],
		protosIndex          => { },
		scene                => [ ],
		imports              => [ ],
		routes               => [ ],
		exports              => [ ],
		context              => [ ],
		parents              => [ ]
	};

	$self -> {nodes} -> load_from_file ($NodeIndex, "none");

	unshift @{$self -> {contexts}}, $self;

	bless $self, $class;
	return $self;
}

sub escape {
	my ($value) = @_;
	$value =~ s/([\\"])/\\$1/sgo;  # Escape "
	return $value;
}

sub parse {
	my ($self) = @_;

	$self -> x3d ($self -> {dom} -> getDocumentElement ());
}

sub x3d {
	my ($self, $xml) = @_;

	return unless $xml;

	$self -> {specificationVersion} = $xml -> getAttribute ("version");
	$self -> {profile}              = $xml -> getAttribute ("profile");

	$self -> {specificationVersion} = $RecomemndedVersion
		unless $self -> {specificationVersion};

	$self -> validate ($xml);

	foreach my $child ($xml -> getChildnodes ())
	{
		if ($child -> nodeName () eq "head")
		{
			$self -> head ($child);
			next;
		}

		if ($child -> nodeName () eq "Scene")
		{
			$self -> scene ($child);
			next;
		}
	}
}

sub validate {
	my ($self, $xml) = @_;

	#say STDERR $self -> {dom} -> internalSubset () -> publicId ();
	#say STDERR $self -> {dom} -> internalSubset () -> systemId ();

	if (not $self -> {dom} -> internalSubset ())
	{
		my $publicId = "ISO//Web3D//DTD X3D " . $self -> {specificationVersion} . "//EN";
		my $systemId = "$DTDDirectory/x3d-" . $self -> {specificationVersion} . ".dtd";

		unless (-e $systemId)
		{
			$publicId = $RecommendedPublicId;
			$systemId = $RecomemndedSystemId;
		}

		$self -> {dom} -> createInternalSubset ($xml, $publicId, $systemId);

		eval { $self -> {dom} -> validate (); };
	}
}

sub head {
	my ($self, $xml) = @_;

	foreach my $child ($xml -> getChildnodes ())
	{
		if ($child -> nodeName () eq "component")
		{
			$self -> component ($child);
			next;
		}

		if ($child -> nodeName () eq "unit")
		{
			$self -> unit ($child);
			next;
		}

		if ($child -> nodeName () eq "meta")
		{
			$self -> meta ($child);
			next;
		}
	}
}

sub component {
	my ($self, $xml) = @_;

	push @{$self -> {components}}, {
		name  => $xml -> getAttribute ("name"),
		level => $xml -> getAttribute ("level")
	};
}

sub unit {
	my ($self, $xml) = @_;

	push @{$self -> {units}}, {
		category         => $xml -> getAttribute ("category"),
		name             => $xml -> getAttribute ("name"),
		conversionFactor => $xml -> getAttribute ("conversionFactor")
	};
}

sub meta {
	my ($self, $xml) = @_;

	push @{$self -> {metaData}}, {
		name  => $xml -> getAttribute ("name"),
		value => $xml -> getAttribute ("content")
	};
}

sub scene {
	my ($self, $xml) = @_;

	$self -> statements ($xml -> getChildnodes ());
}

sub statements {
	my $self = shift;

	foreach (@_)
	{
		$self -> statement ($_);
	}
}

sub statement {
	my ($self, $xml) = @_;

	if ($xml -> getName () eq "ExternProtoDeclare")
	{
		$self -> externProtoDeclare ($xml);
		return;
	}

	if ($xml -> getName () eq "ProtoDeclare")
	{
		$self -> protoDeclare ($xml);
		return;
	}

	if ($xml -> getName () eq "ProtoInstance")
	{
		$self -> protoInstance ($xml);
		return;
	}

	if ($xml -> getName () eq "IS")
	{
		$self -> is ($xml);
		return;
	}

	if ($xml -> getName () eq "ROUTE")
	{
		$self -> route ($xml);
		return;
	}

	if ($xml -> getName () eq "IMPORT")
	{
		$self -> import ($xml);
		return;
	}

	if ($xml -> getName () eq "EXPORT")
	{
		$self -> export ($xml);
		return;
	}

	$self -> node ($xml)
		if $xml -> nodeType () == XML_ELEMENT_NODE;
}

sub externProtoDeclare {
	my ($self, $xml) = @_;

	my $metadata = {
		userDefined   => 1,
		appinfo       => "",
		documentation => "",
		accessType    => "inputOutput",
		type          => "SFNode",
		name          => "metadata",
		value         => "NULL"
	};

	my $externProto = {
		name          => $xml -> getAttribute ("name"),
		appinfo       => $xml -> getAttribute ("appinfo"),
		documentation => $xml -> getAttribute ("documentation"),
		fieldIndex    => { metadata => $metadata },
		interface     => [ ],
		url           => $xml -> getAttribute ("url")
	};

	foreach my $child ($xml -> getChildnodes ())
	{
		if ($child -> nodeName () eq "field")
		{
			$self -> field ($child, $externProto, $externProto -> {interface});
			next;
		}
	}

	my $context = $self -> {contexts} -> [0];

	push @{$context -> {externProtos}}, $externProto;
	$context -> {externProtosIndex} -> {$externProto -> {name}} = $externProto;
}

sub protoDeclare {
	my ($self, $xml) = @_;

	my $metadata = {
		userDefined   => 1,
		appinfo       => "",
		documentation => "",
		accessType    => "inputOutput",
		type          => "SFNode",
		name          => "metadata",
		value         => "NULL"
	};

	my $proto = {
		context           => $self -> {contexts} -> [0],
		name              => $xml -> getAttribute ("name"),
		appinfo           => $xml -> getAttribute ("appinfo"),
		documentation     => $xml -> getAttribute ("documentation"),
		fieldIndex        => { metadata => $metadata },
		interface         => [ ],
		externProtos      => [ ],
		externProtosIndex => { },
		protos            => [ ],
		protosIndex       => { },
		scene             => [ ],
		imports           => [ ],
		routes            => [ ],
		exports           => [ ]
	};

	foreach my $child ($xml -> getChildnodes ())
	{
		if ($child -> nodeName () eq "ProtoInterface")
		{
			$self -> protoInterface ($child, $proto, $proto -> {interface});
			next;
		}

		if ($child -> nodeName () eq "ProtoBody")
		{
			unshift @{$self -> {contexts}}, $proto;

			$self -> protoBody ($child);

			shift @{$self -> {contexts}};
			next;
		}
	}

	my $context = $self -> {contexts} -> [0];

	push @{$context -> {protos}}, $proto;
	$context -> {protosIndex} -> {$proto -> {name}} = $proto;
}

sub protoInterface {
	my ($self, $xml, $proto, $interface) = @_;

	foreach my $child ($xml -> getChildnodes ())
	{
		if ($child -> nodeName () eq "field")
		{
			$self -> field ($child, $proto, $interface);
			next;
		}
	}
}

sub field {
	my ($self, $xml, $node, $interface) = @_;

	my $field = {
		userDefined   => 1,
		appinfo       => $xml -> getAttribute ("appinfo"),
		documentation => $xml -> getAttribute ("documentation"),
		accessType    => $xml -> getAttribute ("accessType"),
		type          => $xml -> getAttribute ("type"),
		name          => $xml -> getAttribute ("name")
	};

	$field -> {accessType} = "initializeOnly"
		unless $field -> {accessType};

	$field -> {value} = $xml -> getAttribute ("value")
		if $xml -> getAttribute ("value");

	$node -> {fieldIndex} -> {$field -> {name}} = $field;
	push @$interface, $field;

	unshift @{$self -> {parents}}, $field;
	$self -> statements ($xml -> getChildnodes ());
	shift @{$self -> {parents}};
}

sub protoBody {
	my ($self, $xml) = @_;

	$self -> statements ($xml -> getChildnodes ());
}

sub protoInstance {
	my ($self, $xml) = @_;

	my $node = {
		userDefined       => 1,
		context           => $self -> {contexts} -> [0],
	   typeName          => $xml -> getAttribute ("name"),
		fields            => [ ],
		fieldIndex        => { },
		userDefinedFields => [ ],
	};

	if ($xml -> getAttribute ("USE"))
	{
		$node -> {reference} = $xml -> getAttribute ("USE");
	}
	else
	{
		$node -> {name} = $xml -> getAttribute ("DEF");

		unshift @{$self -> {parents}}, $node;

		foreach my $child ($xml -> getChildnodes ())
		{
			if ($child -> nodeName () eq "fieldValue")
			{
				$self -> fieldValue ($child, $node);
				next;
			}

			if ($child -> nodeName () eq "IS")
			{
				$self -> is ($child);
				next;
			}
		}

		shift @{$self -> {parents}};
	}

	$self -> addNode ($xml, $node);
}

sub fieldValue {
	my ($self, $xml, $node) = @_;

	my $name = $xml -> getAttribute ("name");

	my $field = {
		fieldValue => 1,
		name       => $name
	};

	push @{$node -> {fields}}, $field;
	$node -> {fieldIndex} -> {$name} = $field;

	$field -> {value} = $xml -> getAttribute ("value")
		if $xml -> getAttribute ("value");

	unshift @{$self -> {parents}}, $field;
	$self -> statements ($xml -> getChildnodes ());
	shift @{$self -> {parents}};
}

sub is {
	my ($self, $xml) = @_;

	my $node       = $self -> {parents} -> [0];
	my $fieldIndex = $node -> {fieldIndex};

	foreach ($xml -> getChildnodes ())
	{
		$self -> connect ($_, $node)
			if $_ -> getName () eq "connect";
	}
}

sub connect {
	my ($self, $xml, $node) = @_;

	my $fieldIndex = $node -> {fieldIndex};
	my $nodeField  = $xml -> getAttribute ("nodeField");

	unless (exists $fieldIndex -> {$nodeField})
	{
		my $field = { };

		push @{$node -> {fields}}, $field;
		$fieldIndex -> {$nodeField} = $field;
	}

	my $field = $fieldIndex -> {$nodeField};

	unless (exists $field -> {references})
	{
		$field -> {references} = [];
	}

	$field -> {name}      = $nodeField;
	push @{$field -> {references}}, $xml -> getAttribute ("protoField");
}

sub node {
	my ($self, $xml) = @_;

	my $node = {
		context           => $self -> {contexts} -> [0],
		typeName          => $xml -> getName (),
		fields            => [ ],
		fieldIndex        => { },
		userDefinedFields => [ ]
	};

	if ($xml -> getAttribute ("USE"))
	{
		$node -> {reference} = $xml -> getAttribute ("USE");
	}
	else
	{
		$node -> {name} = $xml -> getAttribute ("DEF");

		unshift @{$self -> {parents}}, $node;

		$self -> attributes ($xml, $node);

		foreach my $child ($xml -> getChildnodes ())
		{
			if ($child -> getName () eq "field")
			{
				$self -> field ($child, $node, $node -> {userDefinedFields});
				next;
			}

			if ($child -> getName () eq "#cdata-section")
			{
				if ($self -> {nodes} -> has_key ($node -> {typeName}, "url"))
				{
					$self -> cdata ($child, $node);
					next;
				}
			}

			if ($child -> getName () eq "#text")
			{
				if ($self -> {nodes} -> has_key ($node -> {typeName}, "url"))
				{
					$self -> cdata ($child, $node);
					next;
				}
			}

			$self -> statement ($child);
		}

		shift @{$self -> {parents}};
	}

	$self -> addNode ($xml, $node);
}

sub cdata {
	my ($self, $xml, $node) = @_;

	return if $xml -> getValue () =~ /^\s*$/sgo; # BUG: sometimes there are phantom cdata.

	my $fieldIndex = $node -> {fieldIndex};

	if ($fieldIndex -> {url})
	{
		if ($fieldIndex -> {url} -> {value})
		{
			if ($fieldIndex -> {url} -> {value} !~ /^\s*"/sgo)
			{
				$fieldIndex -> {url} -> {value} = "\"" . $fieldIndex -> {url} -> {value} . "\""
			}
		}
		else
		{
			$fieldIndex -> {url} -> {value} = "";
		}
	}
	else
	{
		my $field = {
			name  => "url",
			value => ""
		};

		push @{$node -> {fields}}, $field;
		$fieldIndex -> {url} = $field;
	}

	my $value = $xml -> getValue ();

	$fieldIndex -> {url} -> {value} .= ' "' . escape ($value) . '"';
}

sub addNode {
	my ($self, $xml, $node) = @_;

	if (@{$self -> {parents}})
	{
		my $parent = $self -> {parents} -> [0];
		my $field  = $parent;

		if (exists $parent -> {fieldIndex})
		{
			# Parent is a node

			my $fieldIndex     = $parent -> {fieldIndex};
			my $containerField = $xml -> getAttribute ("containerField");

			## If containerField is '' use default value for containerField.
			unless ($containerField)
			{
				$containerField = $self -> {nodes} -> get_string ($node -> {typeName}, "containerField");
			}

			unless (exists $fieldIndex -> {$containerField})
			{
				my $field = {
					name  => $containerField,
					value => [ ]
				};

				push @{$parent -> {fields}}, $field;
				$fieldIndex -> {$containerField} = $field;
			}

			$field = $fieldIndex -> {$containerField};
		}
		# else parent is a custom field

		$field -> {value} = [ ]
			unless exists $field -> {value};

		push @{$field -> {value}}, $node;
	}
	else
	{
		push @{$self -> {contexts} -> [0] -> {scene}}, $node;
	}
}

sub attributes {
	my ($self, $xml, $node) = @_;

	foreach my $attribute ($xml -> getAttributes ())
	{
		my $name = $attribute -> getName ();

		next if $name =~ /DEF|USE|containerField|class/sgo;

		my $field = {
			name  => $name,
			value => $attribute -> getValue ()
		};

		push @{$node -> {fields}}, $field;
		$node -> {fieldIndex} -> {$name} = $field;
	}
}

sub import {
	my ($self, $xml) = @_;

	push @{$self -> {contexts} -> [0] -> {imports}}, {
		inline       => $xml -> getAttribute ("inlineDEF"),
		exportedName => $xml -> getAttribute ("exportedDEF"),
		localName    => $xml -> getAttribute ("AS")
	};
}

sub route {
	my ($self, $xml) = @_;

	push @{$self -> {contexts} -> [0] -> {routes}}, {
		fromNode  => $xml -> getAttribute ("fromNode"),
		fromField => $xml -> getAttribute ("fromField"),
		toNode    => $xml -> getAttribute ("toNode"),
		toField   => $xml -> getAttribute ("toField")
	};
}

sub export {
	my ($self, $xml) = @_;

	push @{$self -> {contexts} -> [0] -> {exports}}, {
		localName    => $xml -> getAttribute ("localDEF"),
		exportedName => $xml -> getAttribute ("AS")
	};
}

1;

package X3D::Generator;

use strict;
use warnings;
use v5.10.0;
use open qw/:std :utf8/;

sub new {
	my ($class, $document) = @_;

	my $self = {
		document   => $document,
		nodes      => $document -> {nodes},
		fields     => new Glib::KeyFile (),
		indent     => 0,
		indentChar => "  "
	};

	$self -> {fields} -> load_from_file ($FieldIndex, "none");

	bless $self, $class;
	return $self;
}

sub indent {
	my ($self) = @_;
	return $self -> {indentChar} x $self -> {indent};
}

sub escape {
	my ($value) = @_;

	my $result;

	while ($value =~ /\G(.)/sgo)
	{
		switch ($1)
		{
			case "\\"
			{
				if ($value =~ /\G(.)/sgo)
				{
					switch ($1)
					{
						case "\""
						{
							$result .= "\\\"";
						}
						case "\\"
						{
							$result .= "\\\\";
						}
						else
						{
							$result .= $1;
						}
					}
				}
			}
			case "\""
			{
				$result .= "\\\"";
			}
			else
			{
				$result .= $1;
			}
		}
	}

	return $result;
}

sub getPrototype {
	my ($self, $context, $name) = @_;

	return $context -> {externProtosIndex} -> {$name}
		if exists $context -> {externProtosIndex} -> {$name};

	return $context -> {protosIndex} -> {$name}
		if exists $context -> {protosIndex} -> {$name};

	return $self -> getPrototype ($context -> {context}, $name)
		if $context -> {context};
}

sub output {
	my ($self) = @_;
	$self -> scene ();
}

sub scene {
	my ($self) = @_;

	print "#X3D V", $self -> {document} -> {specificationVersion}, " utf8\n\n";

	$self -> profile    ($self -> {document} -> {profile});
	$self -> components ($self -> {document} -> {components});
	$self -> units      ($self -> {document} -> {units});
	$self -> metaData   ($self -> {document} -> {metaData});

	$self -> externProtos (@{$self -> {document} -> {externProtos}});
	$self -> protos       (@{$self -> {document} -> {protos}});
	$self -> nodes        (@{$self -> {document} -> {scene}});
	$self -> imports      (@{$self -> {document} -> {imports}});
	$self -> routes       (@{$self -> {document} -> {routes}});
	$self -> exports      (@{$self -> {document} -> {exports}});
}

sub profile {
	my ($self, $profile) = @_;

	print "PROFILE ", $profile, "\n\n"
		if $profile;
}

sub components {
	my ($self, $components) = @_;

	foreach (@$components)
	{
		print "COMPONENT ", $_ -> {name}, " : ", $_ -> {level}, "\n";
	}

	print "\n" if @$components;
}

sub units {
	my ($self, $units) = @_;

	foreach (@$units)
	{
		print "UNIT ", $_ -> {category}, " ", $_ -> {name}, " ", $_ -> {conversionFactor}, "\n";
	}

	print "\n" if @$units;
}

sub metaData {
	my ($self, $metaData) = @_;

	foreach (@$metaData)
	{
		print "META \"", escape ($_ -> {name}), "\" \"", escape ($_ -> {value}), "\"\n";
	}

	print "\n" if @$metaData;
}

sub externProtos {
	my $self = shift;

	for (@_)
	{
		print $self -> indent ();
		$self -> externProto ($_);
		print "\n\n";
	}

	print "\n" if @_;
}

sub externProto {
	my ($self, $externProto) = @_;

	print "EXTERNPROTO ", $externProto -> {name}, " [";

	if (@{$externProto -> {interface}})
	{
		print "\n";
		++ $self -> {indent};

		$self -> restrictedInterfaceDeclarations (@{$externProto -> {interface}});

		-- $self -> {indent};
		print $self -> indent ();
		print "]\n";
	}
	else
	{
		print " ]\n";
	}

	print $self -> indent ();
	$self -> MFString ($externProto -> {url});
}

sub restrictedInterfaceDeclarations {
	my $self = shift;

	foreach (@_)
	{
		$self -> restrictedInterfaceDeclaration ($_);
	}
}

sub restrictedInterfaceDeclaration {
	my ($self, $field) = @_;

	$self -> documentation ($field);

	print $self -> indent ();
	print
		$field -> {accessType},
		" ",
		$field -> {type},
		" ",
		$field -> {name},
		"\n";
}

sub documentation {
	my ($self, $object) = @_;

	print $self -> indent (), "# " , $object -> {appinfo}, "\n"
		if $object -> {appinfo};

	if ($object -> {documentation})
	{
		print $self -> indent (), "# \n"
			if $object -> {appinfo};

		print $self -> indent (), "# DOCUMENTATION\n";
		print $self -> indent (), "# " , $object -> {documentation}, "\n";
	}
}

sub protos {
	my $self = shift;

	for (@_)
	{
		print $self -> indent ();
		$self -> proto ($_);
		print "\n\n";
	}

	print "\n" if @_;
}

sub proto {
	my ($self, $proto) = @_;

	$self -> documentation ($proto);

	print "PROTO ", $proto -> {name}, " [";

	if (@{$proto -> {interface}})
	{
		print "\n";
		++ $self -> {indent};

		$self -> interfaceDeclarations (@{$proto -> {interface}});

		-- $self -> {indent};
		print $self -> indent ();
		print "]\n";
	}
	else
	{
		print " ]\n";
	}

	print $self -> indent ();
	print "{\n";
	++ $self -> {indent};

	$self -> externProtos (@{$proto -> {externProtos}});
	$self -> protos       (@{$proto -> {protos}});
	$self -> nodes        (@{$proto -> {scene}});
	$self -> imports      (@{$proto -> {imports}});
	$self -> routes       (@{$proto -> {routes}});

	-- $self -> {indent};
	print $self -> indent ();
	print "}\n";
}

sub interfaceDeclarations {
	my $self = shift;

	foreach (@_)
	{
		$self -> interfaceDeclaration ($_);
	}
}

sub interfaceDeclaration {
	my ($self, $field) = @_;

	$self -> documentation ($field);

	print $self -> indent ();
	print
		$field -> {accessType},
		" ",
		$field -> {type},
		" ",
		$field -> {name};

	if ($field -> {accessType} =~ /initializeOnly|inputOutput/sgo)
	{
		print " ";
		$self -> field ([$field -> {name}, $field -> {accessType}, $field -> {type}], $field);
	}

	print "\n";
}

sub nodes {
	my $self = shift;

	for (@_)
	{
		print $self -> indent ();
		$self -> node ($_);
		print "\n\n";
	}

	print "\n" if @_;
}

sub node {
	my ($self, $node) = @_;

	if ($node -> {reference})
	{
		print "USE ", $node -> {reference};
		return;
	}

	if ($self -> {nodes} -> has_group ($node -> {typeName}) or $node -> {userDefined})
	{
		print "DEF ", $node -> {name}, " " if $node -> {name};
		print $node -> {typeName}, " {";

		if (%{$node -> {fieldIndex}})
		{
			print "\n";
			++ $self -> {indent};

			$self -> userDefinedFields ($node);
			$self -> fields ($node);

			-- $self -> {indent};
			print $self -> indent ();
			print "}";
		}
		else
		{
			print " }";
		}
	}
}

my %Depreciated = (
	navType   => ["navType",   "inputOutput", "MFString", "\"EXAMINE\""],
	headlight => ["headlight", "inputOutput", "SFBool",   "TRUE"]
);

sub fields {
	my ($self, $node) = @_;

	foreach my $field (@{$node -> {fields}})
	{
		next if $field -> {userDefined};

		foreach my $reference (@{$field -> {references}})
		{
			print $self -> indent ();
			print $field -> {name}, " ";

			print "IS ", $reference;
			print "\n";
		}

		if ($field -> {fieldValue})
		{
			my $proto           = $self -> getPrototype ($node -> {context}, $node -> {typeName});
			my $fieldDefinition = $proto -> {fieldIndex} -> {$field -> {name}};
			my $accessType      = $fieldDefinition -> {accessType};

			if ($accessType =~ /initializeOnly|inputOutput/sgo)
			{
				print $self -> indent ();
				print $field -> {name}, " ";
	
				$self -> field ([$fieldDefinition -> {name}, $fieldDefinition -> {accessType}, $fieldDefinition -> {type}], $field);
			}
		}
		elsif (defined $field -> {value})
		{
			my $fieldDefinition = $self -> {nodes} -> has_key ($node -> {typeName}, $field -> {name})
                               ? [$self -> {nodes} -> get_string_list ($node -> {typeName}, $field -> {name})]
			                      : $Depreciated {$field -> {name}};

			if (defined $fieldDefinition)
			{
				my $accessType = $fieldDefinition -> [1];
	
				if ($accessType =~ /initializeOnly|inputOutput/sgo)
				{
					print $self -> indent ();
					print $field -> {name}, " ";
		
					$self -> field ($fieldDefinition, $field);
				}
			}
		}

		print "\n";
	}
}

sub userDefinedFields {
	my ($self, $node) = @_;

	foreach my $field (@{$node -> {userDefinedFields}})
	{
		foreach my $reference (@{$field -> {references}})
		{
			print $self -> indent ();
			print $field -> {accessType}, " ";
			print $field -> {type}, " ";
			print $field -> {name};

			print " IS ", $reference;

			print "\n";
		}

		if (not @{$field -> {references}} or defined $field -> {value})
		{
			print $self -> indent ();
			print $field -> {accessType}, " ";
			print $field -> {type}, " ";
			print $field -> {name};

			if ($field -> {accessType} =~ /initializeOnly|inputOutput/sgo)
			{
				print " ";
				$self -> field ([$field -> {name}, $field -> {accessType}, $field -> {type}], $field);
			}

			print "\n";
		}
	}
}

sub field {
	my ($self, $fieldDefinition, $field) = @_;

	my $typeName = $fieldDefinition -> [2];

	if ($typeName eq "SFBool")
	{
		exists $field -> {value}
		? print uc $field -> {value}
		: print "FALSE";
	}
	elsif ($typeName eq "SFNode")
	{
		ref ($field -> {value}) eq "ARRAY"
		? $self -> node ($field -> {value} -> [$#{$field -> {value}}])
		: print "NULL";
	}
	elsif ($typeName eq "SFString")
	{
		exists $field -> {value}
		? print "\"", escape ($field -> {value}), "\""
		: print "\"\"";
	}
	elsif ($typeName eq "MFBool")
	{
		exists $field -> {value}
		? print "[ ", uc ($field -> {value}) , "]"
		: print "[ ]";
	}
	elsif ($typeName eq "MFNode")
	{
		if (exists $field -> {value})
		{
			if (ref ($field -> {value}) eq ref ([ ]))
			{
				print "[\n";
				++ $self -> {indent};

				foreach (@{$field -> {value}})
				{
					print $self -> indent ();

					$self -> node ($_);
					print "\n";
				}

				-- $self -> {indent};
				print $self -> indent ();
				print "]";
			}
			else
			{
				print "[ ", uc ($field -> {value}), " ]";
			}
		}
		else
		{
			print "[ ]";
		}
	}
	elsif ($typeName eq "MFString")
	{
		$self -> MFString ($field -> {value});
	}
	elsif ($typeName =~ /^SF/sgo)
	{
		if (exists $field -> {value})
		{
			print $field -> {value};
		}
		else
		{
			print $self -> {fields} -> get_string ($typeName, "value")
				if $self -> {fields} -> has_group ($typeName);
		}
	}
	else # /^MF/
	{
		exists $field -> {value}
		? print "[ ", $field -> {value} , " ]"
		: print "[ ]";
	}
}

sub MFString {
	my ($self, $value) = @_;

	if ($value)
	{
		if ($value =~ /^\s*"/sgo)
		{
			print "[ ", $value , "]";
		}
		else
		{
			print "[ \"", escape ($value) , "\" ]";
		}
	}
	else
	{
		print "[ ]";
	}
}

sub imports {
	my $self = shift;

	for (@_)
	{
		print $self -> indent ();
		$self -> import ($_);
		print "\n";
	}

	print "\n" if @_;
}

sub import {
	my ($self, $import) = @_;

	print "IMPORT ";
	print $import -> {inline}, ".", $import -> {exportedName};

	if ($import -> {localName})
	{
		print " AS ";
		print $import -> {localName};
	}
}

sub routes {
	my $self = shift;

	for (@_)
	{
		print $self -> indent ();
		$self -> route ($_);
		print "\n";
	}

	print "\n" if @_;
}

sub route {
	my ($self, $route) = @_;

	print "ROUTE ";
	print $route -> {fromNode}, ".", $route -> {fromField};
	print " TO ";
	print $route -> {toNode}, ".", $route -> {toField};
}

sub exports {
	my $self = shift;

	for (@_)
	{
		print $self -> indent ();
		$self -> export ($_);
		print "\n";
	}

	print "\n" if @_;
}

sub export {
	my ($self, $export) = @_;

	print "EXPORT ";
	print $export -> {localName};

	if ($export -> {exportedName})
	{
		print " AS ";
		print $export -> {exportedName};
	}
}

1;
package main;
use strict;
use warnings;
use v5.10.0;

eval {
	my $options = { recover => 2 };
	
	if (@ARGV)
	{
		$options -> {location} = shift @ARGV;
	}
	else
	{
		binmode (STDIN);

		$options -> {string} = join '', <STDIN>;
	}
	
	my $parser = new X3D::Parser ($options);
	$parser -> parse ();
	
	my $generator = new X3D::Generator ($parser);
	$generator -> output ();
};

if ($@)
{
	print STDERR $@;
	exit 1;
}

1;
__END__

# How to update indices
titania-info -i=nodes 2>/dev/null >~/Projekte/Titania/x3d2vrml/share/titania/info/node-index.txt
titania-info -f 2>/dev/null >~/Projekte/Titania/x3d2vrml/share/titania/info/field-index.txt
