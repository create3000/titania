#X3D V3.0 utf8

META "title" "Water 2 Shader"

PROTO ElapsedTime [
  outputOnly SFTime time
]
{
  DEF Timer TimeSensor {
    cycleInterval 10
    loop TRUE
  }

  DEF ElapsedTime Script {
    inputOnly      SFTime set_time
    outputOnly     SFTime time_changed IS time
    inputOnly      SFTime set_startTime
    initializeOnly SFTime startTime 0
    inputOutput    SFTime start 0

    url "vrmlscript:
function initialize ()
{
	start = 0;
}
  
function set_time (value)
{
	time_changed = value - startTime;
}

function set_startTime (value, time)
{
	startTime = time;
}
"
  }

  ROUTE Timer.time TO ElapsedTime.set_time
  ROUTE ElapsedTime.start_changed TO ElapsedTime.set_startTime
}

Background {
  skyColor 0.2 0.2 0.2
}

Viewpoint {
  position 33.7769 17.0666 56.784
  orientation -0.649105 0.758365 0.059544 0.54794
  centerOfRotation 14.5 0 14.5
}

DEF Timer ElapsedTime { }

Transform {
  children Shape {
    appearance Appearance {
      shaders DEF Water ComposedShader {
        inputOutput SFTime  time 0
        inputOutput SFInt32 numWaves 5
        inputOutput MFFloat amplitude [ 0.1, 0.2, 0.1, 0.1, 0.1 ]
        inputOutput MFFloat waveLength [ 1, 2, 3, 4, 5 ]
        inputOutput MFFloat speed [ 1, 2, 1, 2, 1 ]
        inputOutput MFVec2f direction [ 0.1 0.2, 0.3 0.4, 0.5 0.6, 0.7 0.8, 0.9 0.1 ]
        inputOutput SFNode  envMap ComposedCubeMapTexture {
          front ImageTexture {
            url "../CubeMapTexturing/images/lostvalley_south.png"
          }
          back ImageTexture {
            url "../CubeMapTexturing/images/lostvalley_north.png"
          }
          left ImageTexture {
            url "../CubeMapTexturing/images/lostvalley_west.png"
          }
          right ImageTexture {
            url "../CubeMapTexturing/images/lostvalley_east.png"
          }
          bottom ImageTexture {
            url "../CubeMapTexturing/images/lostvalley_down.png"
          }
          top ImageTexture {
            url "../CubeMapTexturing/images/lostvalley_up.png"
          }
        }

        language "GLSL"
        parts [
          ShaderPart {
            url "data:text/plain,
uniform float time;
uniform int numWaves;
uniform float amplitude [8];
uniform float waveLength [8];
uniform float speed [8];
uniform vec2 direction [8];

varying vec3 position;
varying vec3 worldNormal;
varying vec3 eyeNormal;

const float pi = 3.14159;

float wave(int i, float x, float y) {
    float frequency = 2*pi/waveLength[i];
    float phase = speed[i] * frequency;
    float theta = dot(direction[i], vec2(x, y));
    return amplitude[i] * sin(theta * frequency + time * phase);
}

float waveHeight(float x, float y) {
    float height = 0.0;
    for (int i = 0; i < numWaves; ++i)
        height += wave(i, x, y);
    return height;
}

float dWavedx(int i, float x, float y) {
    float frequency = 2*pi/waveLength[i];
    float phase = speed[i] * frequency;
    float theta = dot(direction[i], vec2(x, y));
    float A = amplitude[i] * direction[i].x * frequency;
    return A * cos(theta * frequency + time * phase);
}

float dWavedy(int i, float x, float y) {
    float frequency = 2*pi/waveLength[i];
    float phase = speed[i] * frequency;
    float theta = dot(direction[i], vec2(x, y));
    float A = amplitude[i] * direction[i].y * frequency;
    return A * cos(theta * frequency + time * phase);
}

vec3 waveNormal(float x, float y) {
    float dx = 0.0;
    float dy = 0.0;
    for (int i = 0; i < numWaves; ++i) {
        dx += dWavedx(i, x, y);
        dy += dWavedy(i, x, y);
    }
    vec3 n = vec3(-dx, -dy, 1.0);
    return normalize(n);
}

void main() {
    vec4 pos = gl_Vertex;
    pos.y = waveHeight(pos.x, pos.z);
    position = pos.xyz / pos.w;
    worldNormal = waveNormal(pos.x, pos.z);
    eyeNormal = gl_NormalMatrix * worldNormal;
    gl_Position = gl_ModelViewProjectionMatrix * pos;
}
"
          }
          ShaderPart {
            type "FRAGMENT"
            url "data:text/plain,
varying vec3 position;
varying vec3 worldNormal;
varying vec3 eyeNormal;
uniform vec3 eyePos;
uniform samplerCube envMap;

void main() {
     vec3 eye = normalize(eyePos - position);
     vec3 r = reflect(eye, worldNormal);
     vec4 color = textureCube(envMap, r);
     color.a = 0.5;
     gl_FragColor = color;
}
"
          }
        ]
      }
    }
    geometry ElevationGrid {
      solid FALSE
      xDimension 30
      zDimension 30
    }
  }
}

ROUTE Timer.time TO Water.set_time
